title: Embracing JavaScript
----
subtitle: A few tips for building production-grade Node.js applications.
----
date: 01/15/2014
----
text:
In a previous life, I was a professional web developer. I've used JavaScript extensively throughout my career, but I always saw it as the necessary evil: a weird little language that existed solely to provide interactive features in your web browser. And to be fair, for most of it's lifespan, this evaluation was accurate: every major vendor had their own additions, and developing cross-browser applications was damn hard.

A few years ago, the conversation shifted. Developers everywhere were falling in love with JavaScript, thanks to Ryan Dahl's project, Node.js. Admittedly, my first thought was critical. Why would anyone run this bug-ridden, frustrating language on the server? It would be a pain at best, and downright disastrous at worst, or so I thought.

Nevertheless, I was curious. I downloaded Node and tried it on several pet-projects. It was alright, but no better than Ruby, my previous language of choice.

Last week, I released my first serious Node application: a port of [The Machine](http://machine.fm)'s core analytics platform. During the rewrite, I was able to directly compare the JavaScript implementation to what I previously wrote in Ruby, and the comparison yielded staggering results. The code was much cleaner, and it benchmarked over 30-times faster than the previous system. This newfound perspective opened by eyes, and silenced my critical tongue. JavaScript is cool, and it's here to stay.

But it wasn't all easy. Coming from the world of Ruby, Sinatra, and Rails, choosing the right design was difficult. Node unopinionated, and thus every framework built on top of it is too. With regards to application structure, it's still the wild-west of software development, where anything goes. While some may dispute the tips below, here is a brief list of tricks that helped me make the jump:

## CommonJS Is Your Friend

In the world of Ruby, Python, or PHP, your code only has three main structures: everything is bare, you bundle methods into classes, or maybe include a module or two. But at the core, everything is encapsulated in a language-defined container. CommonJS, which powers the ```require()``` construct in Node.js is different, and from my experience, far more flexible.

It allows you to easily bundle related methods into one or more modules, using two special variables: ```exports``` makes it easy to expose default values, one-off function calls, or any other data type allowed in JavaScript. I've used it for objects, arrays, and initialization code that would be tedious to type repeatedly by hand. ```module.exports```, it's big brother, is used when you only need to export _one object_ from your module. This is helpful for wrangling JavaScript's prototypal inheritance chain.

For me, the biggest challenge was understanding how module definitions impacted the structure of my code. What if I needed to require a module several times over? Using Node's ```global``` namespace is a bit dirty, so this is a reasonable question.

Thankfully, Node is smart: and even if you require a module 100 times and in different files, it doesn't increase your RAM usage. Instead, it caches the first ```require()``` and directs subsequent calls to the instance in-memory. If you're worried about memory bloat (as I was), don't be concerned. Write your code in small, maintainable chunks and use CommonJS as it was intended.

## Word to Your Database
