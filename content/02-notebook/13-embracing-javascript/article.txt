title: Embracing JavaScript
----
subtitle: A few tips for building production-grade Node.js applications.
----
date: 01/15/2014
----
text:
In a previous life, I was a professional web developer. I've used JavaScript extensively throughout my career, but I always saw it as the necessary evil: a weird little language that existed solely to provide interactive features in your web browser. And to be fair, for most of it's lifespan, this evaluation was accurate: every major vendor had their own additions, and developing cross-browser applications was damn hard.

A few years ago, the conversation shifted. Developers everywhere were falling in love with JavaScript, thanks to Ryan Dahl's project, Node.js. Admittedly, my first thought was critical. Why would anyone run this bug-ridden, frustrating language on the server? It would be a pain at best, and downright disastrous at worst, or so I thought.

Nevertheless, I was curious. I downloaded Node and tried it on several pet-projects. It was alright, but no better than Ruby, my previous language of choice.

Last week, I released my first serious Node application: a port of [The Machine](http://machine.fm)'s core analytics platform. During the rewrite, I was able to directly compare the JavaScript implementation to what I previously wrote in Ruby, and the comparison yielded staggering results. The code was much cleaner, and it benchmarked over 30-times faster than the previous system. This newfound perspective opened by eyes, and silenced my critical tongue. JavaScript is cool, and it's here to stay.

But it wasn't all easy. Coming from the world of Ruby, Sinatra, and Rails, choosing the right design was difficult. Node unopinionated, and thus every framework built on top of it is too. With regards to application structure, it's still the wild-west of software development, where anything goes. While some may dispute the tips below, here is a brief list of tricks that helped me make the jump:

## CommonJS Is Your Friend

In the world of Ruby, Python, or PHP, your code only has three main structures: everything is bare, you bundle methods into classes, or maybe include a module or two. But at the core, everything is encapsulated in a language-defined container. CommonJS, which powers the ```require()``` construct in Node.js is different, and from my experience, far more flexible.

It allows you to easily bundle related methods into one or more modules, using two special variables: ```exports``` makes it easy to expose default values, one-off function calls, or any other data type allowed in JavaScript. I've used it for objects, arrays, and initialization code that would be tedious to type repeatedly by hand. ```module.exports```, it's big brother, is used when you only need to export _one object_ from your module. This is helpful for wrangling JavaScript's prototypal inheritance chain.

For me, the biggest challenge was understanding how module definitions impacted the structure of my code. What if I needed to require a module several times over? Using Node's ```global``` namespace is a bit dirty, so this is a reasonable question.

Thankfully, Node is smart: and even if you require a module 100 times and in different files, it doesn't increase your RAM usage. Instead, it caches the first ```require()``` and directs subsequent calls to the instance in-memory. If you're worried about memory bloat (as I was), don't be concerned. Write your code in small, maintainable chunks and use CommonJS as it was intended.

## Avoid "Callback Hell"

Traditional languages like Ruby, PHP, and Python are designed to run in the order that they're written, one line after the previous. This is a wonderful idea, but eventually, your program will need to wait. It might sleep until your database returns query data, or pause for user input. This event is all too common, and even in threaded code, waiting too long dramatically reduces performance. Node handles IO differently, opting for the callback structure that was first pioneered in client-side JavaScript. If a callback is present, you're waiting on something.

This provides a clear delineation between code that runs straight-through, and parts of your application that wait on outside data sources. But writing asynchronous code isn't all fun. What if several functions need to run in series? This is a common problem faced by developers writing for platforms like Node, and thankfully, Joyent (the corporate sponsor of Node.js) has the perfect solution.

David Pacheco's [vasync](https://github.com/davepacheco/node-vasync) module offers a suite of facilities for dealing with async flow control. While I would love to see something like this make it into Node core (or even better, the JavaScript language), I'm happy to leave it as a module.

Critics will say this is one of JavaScript's shortcomings, and that it isn't real for prime-time development. I'll kindly ask those folks to shut up. While JavaScript is improving (thanks to the team behind [ECMAScript 6](http://en.wikipedia.org/wiki/ECMAScript#ECMAScript_Harmony_.286th_Edition.29)), today's version is fine, and if you haven't noticed, it's here to stay.

## CoffeeScript is Cancer

Several years ago, Ted Dziuba's post "[Node.js is Cancer](http://pages.citebite.com/b2x0j8q1megb)" sparked a huge debate. Sparks flew from both sides, as critics piled on Dziuba's bandwagon, and Node developers defended the young platform. I obviously don't believe Ted's gospel, but I think there's something equally dangerous knawing at the Node community today: CoffeeScript.

Here's the deal. I _want_ to love CoffeeScript. It's beautiful, clean syntax is enticing, and I've tried to use it on several projects. In the end, I always ditch it for plain, boring JavaScript.

But why? CoffeeScript is incredibly popular, and works for so many developers. I'll answer this in the only way known to programmers: statistics.

1. CoffeeScript is only suitable for client-side development.

With source maps, CoffeeScript is almost a first-world citizen in the browser. If you move it onto the server, there's no clean way (that I've found) to compile a directory of ```.coffee``` files, and maintain their structure. I'm sure a workflow for this problem exists, but what takes more time: using plain JavaScript, or setting up some asinine build script?

For the record, I also know that CoffeeScript can be ```require()```'d from standard JavaScript, or run via the ```coffee``` command. In my tests, both of these methods added 10+ megabytes to my application's required RAM.

Node is designed to be fast and light. Why would I load it down with unnecessary enhancements? Write beautiful JavaScript and be done with it.

2. CoffeeScript isn't moving at the speed of JavaScript

The JavaScript community has embraced Promises as a wonderful alternative to callback-based programming. Personally, I use Promises every day, and they're beautiful to write in vanilla JavaScript. In CoffeeScript, [not so much](http://stackoverflow.com/questions/17510756/chaining-promises-in-coffeescript). To my eyes, CoffeeScript hides too much. It's unclear when you're chaining methods, and in this situation, CoffeeScript introduces far more mental overhead. Listen, even when you're writing CoffeeScript, you're thinking in JavaScript. Your head and hands should speak the same language.

3. There are _two_ versions!

You read that right. Two versions, [each with slight syntax variants](https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script), but both bearing the CoffeeScript name. This is confusing, and another reason why anyone writing modern JavaScript should stay away &mdash; especially newcomers.

From what I know, these projects don't plan on merging; at least, not anytime soon. And while Michael Ficarra has put many hours into his "CoffeeScript Redux" project, the benefits of using it aren't clear.

Before you get on my back, I understand how open source works. If you don't like something, you change it. But it's a common courtesy to differentiate your project from the original to avoid polluting the existing mindshare. This is a classic example of two projects sharing the same space, and thus confusing newcomers to the JavaScript community. If the Node community needs anything, it's for the CoffeeScript debate to end. Nobody on the core team likes it, so I choose to ignore it.
